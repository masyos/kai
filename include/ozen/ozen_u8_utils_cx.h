//	UTF8 char/string utils C++14 constexpr version.
//
//	Copyright(c) 2018, YOSHIDA Masahiro
//	MIT License
#pragma once

#ifndef	OZEN_U8_UTILS_CX_H
#define	OZEN_U8_UTILS_CX_H

#include <cstdint>
#include <array>
#include <string>
#include <string_view>

#include "ozen/ozen_algo_cx.h"

namespace ozen {

	///	@brief	ctype utf8 constexpr version.
	class u8ctype {
	private:
		enum mask_key : std::uint8_t {
			_upper,
			_lower,
			_digit,
			_space,

			_punct,
			_cntrl,
			_blank,
			_xdigit,

			// alpha = lower | upper,
			// alnum = alpha | digit,
			// graph = alnum | punct,
		};
		enum mask : std::uint8_t {
			upper = 1 << mask_key::_upper,
			lower = 1 << mask_key::_lower,
			digit = 1 << mask_key::_digit,
			space = 1 << mask_key::_space,

			punct = 1 << mask_key::_punct,
			cntrl = 1 << mask_key::_cntrl,
			blank = 1 << mask_key::_blank,
			xdigit = 1 << mask_key::_xdigit,

			alpha = lower | upper,
			alnum = alpha | digit,
			graph = alnum | punct,
		};

		static constexpr std::array<std::uint8_t, 256> mask_table{ {
				0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x68,0x28,0x28,0x28,0x28,0x20,0x20,
				0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
				0x48,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
				0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x10,0x10,0x10,0x10,0x10,0x10,
				0x10,0x81,0x81,0x81,0x81,0x81,0x81,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x10,0x10,0x10,0x10,0x10,
				0x10,0x82,0x82,0x82,0x82,0x82,0x82,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
				0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x10,0x10,0x10,0x10,0x20,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
			} };

	public:
		///	@brief	ctype::is
		template <std::uint8_t M>
		static constexpr bool is(int c) {
			return ((mask_table[c] & M) != 0);
		}

		static constexpr bool isupper(int c) { return is<mask::upper>(c); }
		static constexpr bool islower(int c) { return is<mask::lower>(c); }
		static constexpr bool isdigit(int c) { return is<mask::digit>(c); }
		static constexpr bool isspace(int c) { return is<mask::space>(c); }
		static constexpr bool ispunct(int c) { return is<mask::punct>(c); }
		static constexpr bool iscntrl(int c) { return is<mask::cntrl>(c); }
		static constexpr bool isblank(int c) { return is<mask::blank>(c); }
		static constexpr bool isxdigit(int c) { return is<mask::xdigit>(c); }

		static constexpr bool isalpha(int c) { return is<mask::alpha>(c); }
		static constexpr bool isalnum(int c) { return is<mask::alnum>(c); }
		static constexpr bool isgraph(int c) { return is<mask::graph>(c); }

		static constexpr bool isprint(int c) { return (is<mask::graph>(c) | (c == u8' ')); }


		static constexpr int tolower(int c)
		{
			if (isupper(c)) { c = c - u8'A' + u8'a'; }
			return c;
		}

		static constexpr int toupper(int c)
		{
			if (islower(c)) { c = c - u8'a' + u8'A'; }
			return c;
		}

	};

	template <class Str>
	class u8str_utils {
	public:
		using string_type = Str;
		using size_type = typename string_type::size_type;

		static constexpr string_type trim_start(const string_type& s)
		{
			size_type start = 0;
			while(start < s.size()) {
				if(! u8ctype::isspace(s[start])) {
					break;
				}
				++start;
			}
			return s.substr(start);
		}

		static constexpr string_type trim_end(const string_type& s)
		{
			size_type len = s.size();
			while(len > 0) {
				if(!u8ctype::isspace(s[len - 1])) {
					break;
				}
				--len;
			}
			return s.substr(0, len);
		}

		static constexpr string_type trim(const string_type& s)
		{
			return trim_end(trim_start(s));
		}



		static constexpr bool iequals(const string_type& a, const string_type& b)
		{
#if	(__cplusplus <= 201703L)
			return ozen::equal(
#else
			return std::equal(
#endif
						a.begin(), a.end(),
						b.begin(), b.end(),
						[](char a, char b) {
							  return u8ctype::tolower(a) == u8ctype::tolower(b);
						});
		}
	};
	


}





#endif	// OZEN_U8_UTILS_CX_H
